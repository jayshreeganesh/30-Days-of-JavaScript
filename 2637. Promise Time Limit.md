# Promise Time Limit

A JavaScript/TypeScript solution for limiting the execution time of asynchronous functions.

## Problem Description

Given an asynchronous function `fn` and a time limit `t` in milliseconds, create a time-limited version of the input function that follows these rules:

- If `fn` completes within the time limit of `t` milliseconds, the time-limited function should resolve with the result.
- If the execution of `fn` exceeds the time limit, the time-limited function should reject with the string `"Time Limit Exceeded"`.

## Solution

### JavaScript Implementation

```javascript
/**
 * @param {Function} fn
 * @param {number} t
 * @return {Function}
 */
var timeLimit = function(fn, t) {
    return async function(...args) {
        return new Promise((resolve, reject) => {
            // Set up timeout to reject after t milliseconds
            const timeoutId = setTimeout(() => {
                reject("Time Limit Exceeded");
            }, t);
            
            // Execute the original function
            fn(...args)
                .then((result) => {
                    clearTimeout(timeoutId); // Clear timeout if function completes in time
                    resolve(result);
                })
                .catch((error) => {
                    clearTimeout(timeoutId); // Clear timeout if function throws error
                    reject(error);
                });
        });
    };
};
```

### TypeScript Implementation

```typescript
type Fn = (...params: any[]) => Promise<any>;

function timeLimit(fn: Fn, t: number): Fn {
    return async function(...args: any[]) {
        return new Promise((resolve, reject) => {
            const timeoutId = setTimeout(() => {
                reject("Time Limit Exceeded");
            }, t);
            
            fn(...args)
                .then((result) => {
                    clearTimeout(timeoutId);
                    resolve(result);
                })
                .catch((error) => {
                    clearTimeout(timeoutId);
                    reject(error);
                });
        });
    };
}
```

## How It Works

1. **Function Wrapper**: The `timeLimit` function returns a new async function that accepts any arguments.

2. **Promise Race Logic**: Inside the returned function, we create a new promise that handles two scenarios:
   - Resolves with the result of the original function `fn` if it completes in time
   - Rejects with "Time Limit Exceeded" if the timeout is reached

3. **Timeout Management**:
   - A timeout is set to reject the promise after `t` milliseconds
   - If the original function completes (either successfully or with an error), the timeout is cleared using `clearTimeout(timeoutId)`

4. **Comprehensive Error Handling**:
   - Handles successful completion of `fn`
   - Handles errors thrown by `fn`
   - Handles timeout scenarios

## Alternative Approach Using Promise.race

```javascript
var timeLimit = function(fn, t) {
    return async function(...args) {
        const timeoutPromise = new Promise((_, reject) => {
            setTimeout(() => reject("Time Limit Exceeded"), t);
        });
        
        const fnPromise = fn(...args);
        
        return Promise.race([fnPromise, timeoutPromise]);
    };
};
```

**Note**: While more concise, this approach doesn't clean up the timeout when the function completes, which could lead to memory leaks in long-running applications.

## Examples

### Example 1: Function Exceeds Time Limit
```javascript
const slowFn = async (n) => { 
  await new Promise(res => setTimeout(res, 100)); 
  return n * n; 
};
const limited = timeLimit(slowFn, 50);
limited(5).catch(console.log); // "Time Limit Exceeded"
```

### Example 2: Function Completes in Time
```javascript
const fastFn = async (n) => { 
  await new Promise(res => setTimeout(res, 100)); 
  return n * n; 
};
const limited2 = timeLimit(fastFn, 150);
limited2(5).then(console.log); // 25
```

### Example 3: Function with Multiple Arguments
```javascript
const addFn = async (a, b) => { 
  await new Promise(res => setTimeout(res, 120)); 
  return a + b; 
};
const limited3 = timeLimit(addFn, 150);
limited3(5, 10).then(console.log); // 15
```

### Example 4: Function That Throws Error Immediately
```javascript
const errorFn = async () => { 
  throw "Error";
};
const limited4 = timeLimit(errorFn, 1000);
limited4().catch(console.log); // "Error"
```

## Constraints

- `0 <= inputs.length <= 10`
- `0 <= t <= 1000`
- `fn` returns a promise

## Key Features

- **Proper Resource Cleanup**: Clears timeouts when the function completes
- **Comprehensive Error Handling**: Handles both timeout errors and function execution errors
- **Flexible Argument Handling**: Works with functions that take any number of arguments
- **Memory Efficient**: Prevents memory leaks by cleaning up timeouts

## Usage

```javascript
// Create a time-limited version of any async function
const limitedFunction = timeLimit(yourAsyncFunction, timeoutMs);

// Use it like the original function
limitedFunction(arg1, arg2)
    .then(result => console.log('Success:', result))
    .catch(error => console.log('Error:', error));
```

This solution provides a robust way to add execution time limits to asynchronous operations in JavaScript and TypeScript applications.
