# Flatten Deeply Nested Array

## Problem Description

Given a multi-dimensional array `arr` and a depth `n`, return a flattened version of that array. A multi-dimensional array is a recursive data structure that contains integers or other multi-dimensional arrays.

A flattened array is a version of the original array with some or all of the sub-arrays removed and replaced with the actual elements in that sub-array. This flattening operation should only be done if the current depth of nesting is less than `n`. The depth of the elements in the first array are considered to be 0.

**Constraints:**
- 0 <= count of numbers in arr <= 10^5
- 0 <= count of subarrays in arr <= 10^5
- maxDepth <= 1000
- -1000 <= each number <= 1000
- 0 <= n <= 1000

## Examples

### Example 1
**Input:**
```javascript
arr = [1, 2, 3, [4, 5, 6], [7, 8, [9, 10, 11], 12], [13, 14, 15]]
n = 0
```
**Output:**
```javascript
[1, 2, 3, [4, 5, 6], [7, 8, [9, 10, 11], 12], [13, 14, 15]]
```
**Explanation:** Passing a depth of n=0 will always result in the original array because the smallest possible depth of a subarray (0) is not less than n=0.

### Example 2
**Input:**
```javascript
arr = [1, 2, 3, [4, 5, 6], [7, 8, [9, 10, 11], 12], [13, 14, 15]]
n = 1
```
**Output:**
```javascript
[1, 2, 3, 4, 5, 6, 7, 8, [9, 10, 11], 12, 13, 14, 15]
```
**Explanation:** The subarrays starting with 4, 7, and 13 are all flattened because their depth of 0 is less than 1. However [9, 10, 11] remains unflattened because its depth is 1.

### Example 3
**Input:**
```javascript
arr = [[1, 2, 3], [4, 5, 6], [7, 8, [9, 10, 11], 12], [13, 14, 15]]
n = 2
```
**Output:**
```javascript
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]
```
**Explanation:** The maximum depth of any subarray is 1. Thus, all of them are flattened when n=2.

## Solution

### Approach

The solution uses a recursive approach to flatten the array up to the specified depth `n`:

1. **Base Case**: If `n === 0`, return the original array unchanged
2. **Recursive Processing**: For each element in the array:
   - If the element is a number, add it directly to the result
   - If the element is an array and `n > 0`, recursively flatten it with depth `n - 1` and spread the result
   - If the element is an array but `n === 0`, add the array itself to the result

### JavaScript Implementation

```javascript
/**
 * @param {Array} arr
 * @param {number} n
 * @return {Array}
 */
var flat = function (arr, n) {
    if (n === 0) {
        return arr;
    }
    
    const result = [];
    
    for (const item of arr) {
        if (Array.isArray(item) && n > 0) {
            result.push(...flat(item, n - 1));
        } else {
            result.push(item);
        }
    }
    
    return result;
};
```

### TypeScript Implementation

```typescript
type MultiDimensionalArray = (number | MultiDimensionalArray)[];

var flat = function (arr: MultiDimensionalArray, n: number): MultiDimensionalArray {
    if (n === 0) {
        return arr;
    }
    
    const result: MultiDimensionalArray = [];
    
    for (const item of arr) {
        if (Array.isArray(item) && n > 0) {
            result.push(...flat(item, n - 1));
        } else {
            result.push(item);
        }
    }
    
    return result;
};
```

### Complexity Analysis

- **Time Complexity**: O(N) where N is the total number of elements (including nested ones)
- **Space Complexity**: O(D) where D is the maximum depth for recursion stack

## Key Points

- The solution works without using the built-in `Array.flat()` method
- It handles edge cases where `n = 0` by returning the original array
- The recursive approach efficiently processes nested structures while respecting the depth limit
- The solution works for both JavaScript and TypeScript with proper type definitions
