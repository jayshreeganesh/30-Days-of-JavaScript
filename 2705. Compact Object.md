# Compact Object

A TypeScript/JavaScript solution for creating compact objects by removing all falsy values, including from nested structures.

## Problem Description

Given an object or array, return a compact object where all keys containing falsy values are removed. This operation applies to the object and any nested objects. Arrays are considered objects where the indices are keys.

A value is considered falsy when `Boolean(value)` returns `false`.

## Solution

### TypeScript Implementation

```typescript
type JSONValue = null | boolean | number | string | JSONValue[] | { [key: string]: JSONValue };
type Obj = Record<string, JSONValue> | Array<JSONValue>;

function compactObject(obj: Obj): Obj {
    if (obj === null) return null;
    
    if (Array.isArray(obj)) {
        const result: JSONValue[] = [];
        for (const item of obj) {
            const compactedItem = compactObject(item as Obj);
            if (Boolean(compactedItem)) {
                result.push(compactedItem);
            }
        }
        return result;
    }
    
    if (typeof obj === 'object') {
        const result: Record<string, JSONValue> = {};
        for (const [key, value] of Object.entries(obj)) {
            const compactedValue = compactObject(value as Obj);
            if (Boolean(compactedValue)) {
                result[key] = compactedValue;
            }
        }
        return result;
    }
    
    return obj;
}
```

### JavaScript Implementation

```javascript
/**
 * @param {Object|Array} obj
 * @return {Object|Array}
 */
var compactObject = function(obj) {
    if (obj === null) return null;
    
    if (Array.isArray(obj)) {
        return obj
            .map(compactObject)
            .filter(item => Boolean(item));
    }
    
    if (typeof obj === 'object') {
        const result = {};
        for (const [key, value] of Object.entries(obj)) {
            const compactedValue = compactObject(value);
            if (Boolean(compactedValue)) {
                result[key] = compactedValue;
            }
        }
        return result;
    }
    
    return obj;
};
```

## Algorithm

1. **Handle null case**: If input is `null`, return `null` immediately
2. **Array handling**: 
   - Recursively apply `compactObject` to each element
   - Filter out falsy values from the resulting array
3. **Object handling**:
   - Iterate through all key-value pairs
   - Recursively compact each value
   - Only keep keys where the compacted value is truthy
4. **Primitive values**: Return as-is (they'll be filtered out later if falsy)

## Examples

### Example 1
**Input**: `[null, 0, false, 1]`  
**Output**: `[1]`  
**Explanation**: All falsy values (`null`, `0`, `false`) have been removed from the array.

### Example 2
**Input**: `{"a": null, "b": [false, 1]}`  
**Output**: `{"b": [1]}`  
**Explanation**: `obj["a"]` and `obj["b"][0]` had falsy values and were removed.

### Example 3
**Input**: `[null, 0, 5, [0], [false, 16]]`  
**Output**: `[5, [], [16]]`  
**Explanation**: `obj[0]`, `obj[1]`, `obj[3][0]`, and `obj[4][0]` were falsy and removed.

## Falsy Values in JavaScript

The following values are considered falsy in JavaScript:
- `false`
- `null`
- `0`
- `""` (empty string)
- `undefined`
- `NaN`

## Complexity Analysis

- **Time Complexity**: O(n) where n is the total number of elements in the object/array
- **Space Complexity**: O(d) where d is the maximum depth for the recursion stack

## Key Features

- **Recursive processing**: Handles nested objects and arrays
- **Type safety**: Proper TypeScript type definitions
- **Preserves structure**: Maintains the original structure while removing falsy values
- **Empty arrays**: Empty arrays are considered truthy and preserved

## Usage

```typescript
// Example usage
const input1 = [null, 0, false, 1];
const output1 = compactObject(input1); // [1]

const input2 = {"a": null, "b": [false, 1]};
const output2 = compactObject(input2); // {"b": [1]}

const input3 = [null, 0, 5, [0], [false, 16]];
const output3 = compactObject(input3); // [5, [], [16]]
```

This solution efficiently handles all edge cases while maintaining type safety and clean code structure.
