# Counter Function

A JavaScript/TypeScript implementation of a counter function that returns incrementing values with each call.

## Problem Description

Given an integer `n`, return a counter function. This counter function initially returns `n` and then returns 1 more than the previous value every subsequent time it is called (`n`, `n + 1`, `n + 2`, etc).

### Examples

**Example 1:**
```javascript
Input: n = 10, calls = ["call","call","call"]
Output: [10, 11, 12]
Explanation:
counter() = 10 // The first time counter() is called, it returns n.
counter() = 11 // Returns 1 more than the previous time.
counter() = 12 // Returns 1 more than the previous time.
```

**Example 2:**
```javascript
Input: n = -2, calls = ["call","call","call","call","call"]
Output: [-2, -1, 0, 1, 2]
Explanation: counter() initially returns -2. Then increases after each subsequent call.
```

### Constraints
- `-1000 <= n <= 1000`
- `0 <= calls.length <= 1000`
- `calls[i] === "call"`

## Solutions

### JavaScript Solution

```javascript
/**
 * @param {number} n
 * @return {Function} counter
 */
var createCounter = function(n) {
    let count = n;
    
    return function() {
        return count++;
    };
};

// Usage
const counter = createCounter(10);
console.log(counter()); // 10
console.log(counter()); // 11
console.log(counter()); // 12
```

### TypeScript Solution

```typescript
function createCounter(n: number): () => number {
    return function(): number {
        return n++;
    };
}

// Usage
const counter = createCounter(10);
console.log(counter()); // 10
console.log(counter()); // 11
console.log(counter()); // 12
```

## How It Works

The solution uses **closures** to maintain state between function calls:

1. **Closure Concept**: The inner function has access to variables from the outer function's scope, even after the outer function has finished executing.

2. **State Preservation**: The counter variable (`count` or `n`) persists between function calls, allowing the counter to remember its current value.

3. **Post-increment Operator**: The `count++` (or `n++`) syntax returns the current value first, then increments the variable by 1.

## Alternative Implementations

### Explicit JavaScript Version
```javascript
var createCounter = function(n) {
    let count = n;
    
    return function() {
        const current = count;
        count += 1;
        return current;
    };
};
```

### Explicit TypeScript Version
```javascript
function createCounter(n: number): () => number {
    let count: number = n;
    
    return function(): number {
        const currentValue: number = count;
        count++;
        return currentValue;
    };
}
```

## Key Features

- **Simple and Efficient**: O(1) time complexity for each call
- **Memory Efficient**: Uses closure to maintain state without global variables
- **Type Safe** (TypeScript version): Provides compile-time type checking
- **Reusable**: Can create multiple independent counters

## Use Cases

- Generating sequential IDs
- Pagination counters
- Game score tracking
- Any scenario requiring incremental counting with preserved state
