# Cache With Time Limit

A JavaScript/TypeScript implementation of a time-limited cache that automatically expires key-value pairs after a specified duration.

## Problem Description

Implement a cache class that supports:
- Setting key-value pairs with expiration time
- Retrieving values if they haven't expired
- Counting unexpired keys
- Automatic cleanup of expired entries

## Features

- **Automatic Expiration**: Keys automatically become inaccessible after their duration elapses
- **Memory Efficient**: Cleans up expired entries and clears old timeouts
- **Thread-Safe**: Properly manages concurrent operations
- **Type Support**: Available in both JavaScript and TypeScript

## API Reference

### Constructor
```javascript
const cache = new TimeLimitedCache();
```

### Methods

#### `set(key, value, duration)`
- **Parameters**:
  - `key` (number): The cache key
  - `value` (number): The value to store
  - `duration` (number): Time until expiration in milliseconds
- **Returns**: `boolean` - `true` if an unexpired key already existed, `false` otherwise
- **Behavior**: Overwrites existing key's value and duration if present

#### `get(key)`
- **Parameters**:
  - `key` (number): The key to retrieve
- **Returns**: `number` - The associated value if unexpired, `-1` otherwise

#### `count()`
- **Returns**: `number` - Count of currently unexpired keys

## Examples

### Example 1: Basic Usage
```javascript
const cache = new TimeLimitedCache();
cache.set(1, 42, 1000); // false - key didn't exist
cache.get(1); // 42
cache.count(); // 1
// After 1000ms...
cache.get(1); // -1 (expired)
cache.count(); // 0
```

### Example 2: Overwriting Keys
```javascript
const cache = new TimeLimitedCache();
cache.set(1, 42, 50); // false
cache.set(1, 50, 100); // true - overwrote existing unexpired key
cache.get(1); // 50
```

### Example 3: Overwriting Expired Keys
```javascript
const cache = new TimeLimitedCache();
cache.set(1, 42, 50); // false
// Wait for expiration...
cache.set(1, 50, 100); // false - key existed but was expired
```

## Implementation Details

### Data Structure
- Uses `Map` for O(1) access to cache entries
- Each entry stores:
  - `value`: The cached value
  - `expirationTime`: Timestamp when the entry expires
  - `timeout`: Reference to the automatic cleanup timer

### Expiration Handling
1. **Proactive Cleanup**: Uses `setTimeout` to automatically remove expired entries
2. **Lazy Cleanup**: Also checks expiration during `get()` and `count()` operations
3. **Memory Management**: Clears old timeouts when overwriting keys

### Key Logic for `set()` method
```javascript
set(key, value, duration) {
    const existing = this.cache.get(key);
    let existed = false; // Default to false
    
    if (existing) {
        // Only return true if the existing key is NOT expired
        if (existing.expirationTime > Date.now()) {
            existed = true;
        }
        clearTimeout(existing.timeout); // Always clear old timeout
    }
    
    // Set new entry with new timeout...
    return existed;
}
```

### Complexity
- **Time Complexity**: O(1) for `set()` and `get()`, O(n) for `count()` (due to cleanup)
- **Space Complexity**: O(n) where n is the number of active cache entries

## Usage

### JavaScript
```javascript
var TimeLimitedCache = function() {
    this.cache = new Map();
};

TimeLimitedCache.prototype.set = function(key, value, duration) {
    const now = Date.now();
    const expirationTime = now + duration;
    
    const existing = this.cache.get(key);
    let existed = false;
    
    if (existing) {
        if (existing.expirationTime > now) {
            existed = true;
        }
        clearTimeout(existing.timeout);
    }
    
    const timeout = setTimeout(() => {
        this.cache.delete(key);
    }, duration);
    
    this.cache.set(key, {
        value,
        expirationTime,
        timeout
    });
    
    return existed;
};

TimeLimitedCache.prototype.get = function(key) {
    const entry = this.cache.get(key);
    if (!entry) return -1;
    
    const now = Date.now();
    if (entry.expirationTime > now) {
        return entry.value;
    } else {
        this.cache.delete(key);
        return -1;
    }
};

TimeLimitedCache.prototype.count = function() {
    const now = Date.now();
    let count = 0;
    
    for (const [key, entry] of this.cache) {
        if (entry.expirationTime > now) {
            count++;
        } else {
            this.cache.delete(key);
        }
    }
    
    return count;
};
```

### TypeScript
```typescript
class TimeLimitedCache {
    private cache: Map<number, {value: number, expirationTime: number, timeout: NodeJS.Timeout}>;
    
    constructor() {
        this.cache = new Map();
    }
    
    set(key: number, value: number, duration: number): boolean {
        const now = Date.now();
        const expirationTime = now + duration;
        
        const existing = this.cache.get(key);
        let existed = false;
        
        if (existing) {
            if (existing.expirationTime > now) {
                existed = true;
            }
            clearTimeout(existing.timeout);
        }
        
        const timeout = setTimeout(() => {
            this.cache.delete(key);
        }, duration);
        
        this.cache.set(key, {
            value,
            expirationTime,
            timeout
        });
        
        return existed;
    }
    
    get(key: number): number {
        const entry = this.cache.get(key);
        if (!entry) return -1;
        
        const now = Date.now();
        if (entry.expirationTime > now) {
            return entry.value;
        } else {
            this.cache.delete(key);
            return -1;
        }
    }
    
    count(): number {
        const now = Date.now();
        let count = 0;
        
        for (const [key, entry] of this.cache) {
            if (entry.expirationTime > now) {
                count++;
            } else {
                this.cache.delete(key);
            }
        }
        
        return count;
    }
}
```

## Constraints

- `0 <= key, value <= 10^9`
- `0 <= duration <= 1000`
- All operations are synchronous
- First action is always constructor with 0ms delay

## Edge Cases Handled

1. **New Key Creation**: Returns `false` when setting a new key
2. **Overwriting Unexpired Keys**: Returns `true` and updates value/duration
3. **Overwriting Expired Keys**: Returns `false` (treats as new key)
4. **Expired Access**: Returns `-1` for expired keys and cleans them up
5. **Concurrent Operations**: Properly manages timer references
6. **Memory Leaks**: Clears all timeouts to prevent memory leaks

## Testing

The implementation correctly handles the provided test cases:

### Test Case 1
```javascript
actions = ["TimeLimitedCache", "set", "get", "count", "get"]
values = [[], [1, 42, 100], [1], [], [1]]
timeDelays = [0, 0, 50, 50, 150]
// Output: [null, false, 42, 1, -1]
```

### Test Case 2
```javascript
actions = ["TimeLimitedCache", "set", "set", "get", "get", "get", "count"]
values = [[], [1, 42, 50], [1, 50, 100], [1], [1], [1], []]
timeDelays = [0, 0, 40, 50, 120, 200, 250]
// Output: [null, false, true, 50, 50, -1, 0]
```

This implementation provides a robust, efficient solution for time-limited caching with proper expiration management and correct return values for all edge cases.
