# Cache With Time Limit

A JavaScript/TypeScript implementation of a time-limited cache that automatically expires key-value pairs after a specified duration.

## Problem Description

Implement a cache class that supports:
- Setting key-value pairs with expiration time
- Retrieving values if they haven't expired
- Counting unexpired keys
- Automatic cleanup of expired entries

## Features

- **Automatic Expiration**: Keys automatically become inaccessible after their duration elapses
- **Memory Efficient**: Cleans up expired entries and clears old timeouts
- **Thread-Safe**: Properly manages concurrent operations
- **Type Support**: Available in both JavaScript and TypeScript

## API Reference

### Constructor
```javascript
const cache = new TimeLimitedCache();
```

### Methods

#### `set(key, value, duration)`
- **Parameters**:
  - `key` (number): The cache key
  - `value` (number): The value to store
  - `duration` (number): Time until expiration in milliseconds
- **Returns**: `boolean` - `true` if an unexpired key already existed, `false` otherwise
- **Behavior**: Overwrites existing key's value and duration if present

#### `get(key)`
- **Parameters**:
  - `key` (number): The key to retrieve
- **Returns**: `number` - The associated value if unexpired, `-1` otherwise

#### `count()`
- **Returns**: `number` - Count of currently unexpired keys

## Examples

### Example 1: Basic Usage
```javascript
const cache = new TimeLimitedCache();
cache.set(1, 42, 1000); // false - key didn't exist
cache.get(1); // 42
cache.count(); // 1
// After 1000ms...
cache.get(1); // -1 (expired)
cache.count(); // 0
```

### Example 2: Overwriting Keys
```javascript
const cache = new TimeLimitedCache();
cache.set(1, 42, 50); // false
cache.set(1, 50, 100); // true - overwrote existing key
cache.get(1); // 50
```

## Implementation Details

### Data Structure
- Uses `Map` for O(1) access to cache entries
- Each entry stores:
  - `value`: The cached value
  - `expirationTime`: Timestamp when the entry expires
  - `timeout`: Reference to the automatic cleanup timer

### Expiration Handling
1. **Proactive Cleanup**: Uses `setTimeout` to automatically remove expired entries
2. **Lazy Cleanup**: Also checks expiration during `get()` and `count()` operations
3. **Memory Management**: Clears old timeouts when overwriting keys

### Complexity
- **Time Complexity**: O(1) for `set()` and `get()`, O(n) for `count()` (due to cleanup)
- **Space Complexity**: O(n) where n is the number of active cache entries

## Usage

### JavaScript
```javascript
var TimeLimitedCache = function() {
    this.cache = new Map();
};

TimeLimitedCache.prototype.set = function(key, value, duration) {
    // Implementation...
};

TimeLimitedCache.prototype.get = function(key) {
    // Implementation...
};

TimeLimitedCache.prototype.count = function() {
    // Implementation...
};
```

### TypeScript
```typescript
class TimeLimitedCache {
    private cache: Map<number, {value: number, expirationTime: number, timeout: NodeJS.Timeout}>;
    
    constructor() {
        this.cache = new Map();
    }
    
    set(key: number, value: number, duration: number): boolean {
        // Implementation...
    }
    
    get(key: number): number {
        // Implementation...
    }
    
    count(): number {
        // Implementation...
    }
}
```

## Constraints

- `0 <= key, value <= 10^9`
- `0 <= duration <= 1000`
- All operations are synchronous
- First action is always constructor with 0ms delay

## Edge Cases Handled

1. **Overwriting Keys**: Clears existing timeout and updates value/duration
2. **Expired Access**: Returns `-1` for expired keys and cleans them up
3. **Concurrent Operations**: Properly manages timer references
4. **Memory Leaks**: Clears all timeouts to prevent memory leaks

## Testing

The implementation handles the provided examples correctly:

```javascript
// Example 1
actions = ["TimeLimitedCache", "set", "get", "count", "get"]
values = [[], [1, 42, 100], [1], [], [1]]
// Output: [null, false, 42, 1, -1]

// Example 2  
actions = ["TimeLimitedCache", "set", "set", "get", "get", "get", "count"]
values = [[], [1, 42, 50], [1, 50, 100], [1], [1], [1], []]
// Output: [null, false, true, 50, 50, -1, 0]
```

This implementation provides a robust, efficient solution for time-limited caching with automatic expiration management.
