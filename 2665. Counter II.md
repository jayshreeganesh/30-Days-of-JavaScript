# Counter II

A JavaScript/TypeScript implementation of a counter object with increment, decrement, and reset functionality using closures.

## Problem Description

Write a function `createCounter` that accepts an initial integer `init` and returns an object with three functions:

- `increment()` - increases the current value by 1 and returns it
- `decrement()` - reduces the current value by 1 and returns it  
- `reset()` - sets the current value to `init` and returns it

## Examples

### Example 1
```javascript
const counter = createCounter(5);
counter.increment(); // 6
counter.reset();     // 5
counter.decrement(); // 4
```

### Example 2
```javascript
const counter = createCounter(0);
counter.increment(); // 1
counter.increment(); // 2
counter.decrement(); // 1
counter.reset();     // 0
counter.reset();     // 0
```

## Solutions

### JavaScript Solution
```javascript
var createCounter = function(init) {
    let currentValue = init;
    
    return {
        increment: function() {
            currentValue += 1;
            return currentValue;
        },
        decrement: function() {
            currentValue -= 1;
            return currentValue;
        },
        reset: function() {
            currentValue = init;
            return currentValue;
        }
    };
};
```

### TypeScript Solution
```typescript
type Counter = {
    increment: () => number,
    decrement: () => number,
    reset: () => number,
}

function createCounter(init: number): Counter {
    let currentValue = init;
    
    return {
        increment: () => ++currentValue,
        decrement: () => --currentValue,
        reset: () => currentValue = init
    };
};
```

## Key Concepts

### Closure
The solution uses JavaScript's closure mechanism to maintain the state (`currentValue`) across multiple function calls. The inner functions have access to the variables in the outer function's scope even after the outer function has returned.

### State Management
- `currentValue` tracks the current state of the counter
- `init` preserves the original initial value for reset operations
- Each method returns the updated value after performing its operation

## Constraints

- `-1000 <= init <= 1000`
- `0 <= calls.length <= 1000`
- `calls[i]` is one of `"increment"`, `"decrement"`, and `"reset"`

## Complexity Analysis

- **Time Complexity**: O(1) for each operation (increment, decrement, reset)
- **Space Complexity**: O(1) as we only store a constant amount of variables

## Usage

```javascript
// Create a counter starting at 10
const counter = createCounter(10);

// Use the methods
console.log(counter.increment()); // 11
console.log(counter.increment()); // 12
console.log(counter.decrement()); // 11
console.log(counter.reset());     // 10
```

This implementation provides a clean, efficient way to create counter objects with persistent state across multiple operations.
