# 2666. Allow One Function Call

## Problem Description

Given a function `fn`, return a new function that is identical to the original function except that it ensures `fn` is called at most once.

- The first time the returned function is called, it should return the same result as `fn`
- Every subsequent time it is called, it should return `undefined`

## Examples

### Example 1
```javascript
Input: fn = (a,b,c) => (a + b + c), calls = [[1,2,3],[2,3,6]]
Output: [{"calls":1,"value":6}]

Explanation:
const onceFn = once(fn);
onceFn(1, 2, 3); // 6
onceFn(2, 3, 6); // undefined, fn was not called
```

### Example 2
```javascript
Input: fn = (a,b,c) => (a * b * c), calls = [[5,7,4],[2,3,6],[4,6,8]]
Output: [{"calls":1,"value":140}]

Explanation:
const onceFn = once(fn);
onceFn(5, 7, 4); // 140
onceFn(2, 3, 6); // undefined, fn was not called
onceFn(4, 6, 8); // undefined, fn was not called
```

## Solutions

### JavaScript Solution
```javascript
/**
 * @param {Function} fn
 * @return {Function}
 */
var once = function(fn) {
    let called = false;
    
    return function(...args) {
        if (!called) {
            called = true;
            return fn.apply(this, args);
        }
        return undefined;
    }
};
```

### TypeScript Solution
```typescript
type JSONValue = null | boolean | number | string | JSONValue[] | { [key: string]: JSONValue };
type OnceFn = (...args: JSONValue[]) => JSONValue | undefined

function once(fn: Function): OnceFn {
    let called = false;
    
    return function (...args: JSONValue[]): JSONValue | undefined {
        if (!called) {
            called = true;
            return fn.apply(this, args);
        }
        return undefined;
    };
}
```

### Type-Safe TypeScript Solution (Generic)
```typescript
function once<T extends (...args: any[]) => any>(fn: T): (...args: Parameters<T>) => ReturnType<T> | undefined {
    let called = false;
    let result: ReturnType<T> | undefined;
    
    return function (...args: Parameters<T>): ReturnType<T> | undefined {
        if (!called) {
            called = true;
            result = fn.apply(this, args);
            return result;
        }
        return undefined;
    };
}
```

## How It Works

1. **Closure Pattern**: The solution uses JavaScript/TypeScript closures to maintain state between function calls
2. **State Tracking**: A `called` boolean flag tracks whether the wrapped function has been invoked
3. **Single Execution**:
   - First call: Sets `called = true`, executes the original function, and returns its result
   - Subsequent calls: Returns `undefined` without executing the original function
4. **Context Preservation**: Uses `fn.apply(this, args)` to maintain the correct `this` context

## Complexity Analysis

- **Time Complexity**: O(1) for each function call
- **Space Complexity**: O(1) for the closure variables

## Key Concepts

- **Closures**: Functions that remember their lexical scope
- **Higher-Order Functions**: Functions that take other functions as arguments or return functions
- **State Management**: Using closure variables to track call history
- **Function Context**: Preserving `this` binding with `apply()`

## Usage

```javascript
// JavaScript
const onceFn = once((a, b, c) => a + b + c);
console.log(onceFn(1, 2, 3)); // 6
console.log(onceFn(4, 5, 6)); // undefined

// TypeScript
const onceFn = once((a: number, b: number, c: number) => a * b * c);
console.log(onceFn(2, 3, 4)); // 24
console.log(onceFn(5, 6, 7)); // undefined
```
