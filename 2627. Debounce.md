# Debounce Function Implementation

A JavaScript/TypeScript implementation of a debounce function that delays execution and cancels previous calls if invoked again within the delay period.

## Problem Description

Given a function `fn` and a time in milliseconds `t`, return a debounced version of that function.

A debounced function:
- Delays execution by `t` milliseconds
- Cancels execution if called again within the delay window
- Receives and passes all parameters to the original function

### Examples

**Example 1:**
```javascript
t = 50
calls = [
  {"t": 50, inputs: [1]},
  {"t": 75, inputs: [2]}
]
Output: [{"t": 125, inputs: [2]}]
```

**Example 2:**
```javascript
t = 20
calls = [
  {"t": 50, inputs: [1]},
  {"t": 100, inputs: [2]}
]
Output: [{"t": 70, inputs: [1]}, {"t": 120, inputs: [2]}]
```

**Example 3:**
```javascript
t = 150
calls = [
  {"t": 50, inputs: [1, 2]},
  {"t": 300, inputs: [3, 4]},
  {"t": 300, inputs: [5, 6]}
]
Output: [{"t": 200, inputs: [1,2]}, {"t": 450, inputs: [5, 6]}]
```

## Solutions

### JavaScript Implementation

```javascript
/**
 * @param {Function} fn
 * @param {number} t milliseconds
 * @return {Function}
 */
var debounce = function(fn, t) {
    let timeoutId;
    
    return function(...args) {
        // Clear any existing timeout
        clearTimeout(timeoutId);
        
        // Set a new timeout
        timeoutId = setTimeout(() => {
            fn.apply(this, args);
        }, t);
    }
};
```

### TypeScript Implementation

```typescript
type F = (...args: any[]) => void

function debounce(fn: F, t: number): F {
    let timeoutId: ReturnType<typeof setTimeout>;
    
    return function(...args: any[]) {
        clearTimeout(timeoutId);
        timeoutId = setTimeout(() => fn(...args), t);
    }
};
```

### Alternative Implementation (Preserves `this` Context)

```javascript
var debounce = function(fn, t) {
    let timeoutId;
    
    return function(...args) {
        const context = this;
        clearTimeout(timeoutId);
        timeoutId = setTimeout(() => {
            fn.apply(context, args);
        }, t);
    }
};
```

## How It Works

1. **Closure**: The returned function closes over the `timeoutId` variable, which persists between calls
2. **Cancellation**: Every call to the debounced function cancels any previously scheduled execution using `clearTimeout(timeoutId)`
3. **Rescheduling**: A new timeout is set that will execute the original function after `t` milliseconds
4. **Argument Passing**: The spread operator `...args` ensures all arguments are passed to the original function

## Usage

```javascript
// Create a debounced version of console.log with 100ms delay
const log = debounce(console.log, 100);

log('Hello'); // cancelled
log('Hello'); // cancelled  
log('Hello'); // Logged at t=100ms
```

## Complexity Analysis

- **Time Complexity**: O(1) for each function call
- **Space Complexity**: O(1) - only stores the timeout ID

## Key Features

- **Immediate Cancellation**: Any new call immediately cancels the pending execution
- **Proper Argument Handling**: All arguments are correctly passed to the original function
- **Context Preservation**: The alternative implementation preserves the `this` context when the debounced function is called as an object method
- **No External Dependencies**: Pure JavaScript/TypeScript implementation without using lodash

## Use Cases

- Search input fields (wait for user to stop typing)
- Window resize events
- Button click prevention (double-click protection)
- API call optimization (reduce server requests)
